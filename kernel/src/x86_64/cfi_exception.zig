// Copyright 2025 arancormonk
// SPDX-License-Identifier: MIT

// Control Protection Exception Handler for CFI violations
//
// This module handles Control Protection (#CP) exceptions (vector 21)
// generated by Intel CET when CFI violations occur.

const std = @import("std");
const serial = @import("../drivers/serial.zig");
const exceptions = @import("exceptions.zig");
const cfi = @import("cfi.zig");
const stack_security = @import("stack_security.zig");

// Control Protection Exception error codes
pub const CPErrorCode = packed struct {
    near_ret: bool, // bit 0: Near RET check failure
    far_ret_iret: bool, // bit 1: Far RET/IRET check failure
    endbranch: bool, // bit 2: Missing ENDBRANCH at target
    rstorssp: bool, // bit 3: RSTORSSP check failure
    setssbsy: bool, // bit 4: SETSSBSY check failure
    reserved1: u11, // bits 5-15: Reserved
    reserved2: u16, // bits 16-31: Reserved
    reserved3: u32, // bits 32-63: Reserved
};

// Statistics for CP exceptions
var cp_exception_count: std.atomic.Value(u64) = std.atomic.Value(u64).init(0);
var cp_near_ret_violations: std.atomic.Value(u64) = std.atomic.Value(u64).init(0);
var cp_far_ret_violations: std.atomic.Value(u64) = std.atomic.Value(u64).init(0);
var cp_endbranch_violations: std.atomic.Value(u64) = std.atomic.Value(u64).init(0);
var cp_shadow_stack_violations: std.atomic.Value(u64) = std.atomic.Value(u64).init(0);

// Handle Control Protection exception
pub fn handleControlProtection(frame: *exceptions.InterruptFrame, error_code: u64) void {
    var guard = stack_security.protect();
    defer guard.deinit();

    _ = cp_exception_count.fetchAdd(1, .monotonic);

    // Parse error code
    const cp_error = @as(*const CPErrorCode, @ptrCast(&error_code)).*;

    serial.println("\n[CFI] CONTROL PROTECTION EXCEPTION (#CP)", .{});
    serial.println("[CFI] RIP: 0x{x:0>16}", .{frame.rip});
    serial.println("[CFI] RSP: 0x{x:0>16}", .{frame.rsp});
    serial.println("[CFI] Error code: 0x{x:0>16}", .{error_code});

    // Determine violation type
    if (cp_error.near_ret) {
        _ = cp_near_ret_violations.fetchAdd(1, .monotonic);
        serial.println("[CFI] Violation: Near RET check failure", .{});
        serial.println("[CFI] Shadow stack token mismatch on return", .{});
    }

    if (cp_error.far_ret_iret) {
        _ = cp_far_ret_violations.fetchAdd(1, .monotonic);
        serial.println("[CFI] Violation: Far RET/IRET check failure", .{});
        serial.println("[CFI] Shadow stack token mismatch on far return", .{});
    }

    if (cp_error.endbranch) {
        _ = cp_endbranch_violations.fetchAdd(1, .monotonic);
        serial.println("[CFI] Violation: Missing ENDBRANCH at target", .{});
        serial.println("[CFI] Indirect branch to non-ENDBR instruction", .{});

        // Try to identify the source of the indirect branch
        analyzeIndirectBranch(frame);
    }

    if (cp_error.rstorssp or cp_error.setssbsy) {
        _ = cp_shadow_stack_violations.fetchAdd(1, .monotonic);
        serial.println("[CFI] Violation: Shadow stack manipulation", .{});
        if (cp_error.rstorssp) {
            serial.println("[CFI] RSTORSSP check failure", .{});
        }
        if (cp_error.setssbsy) {
            serial.println("[CFI] SETSSBSY check failure", .{});
        }
    }

    // Log CFI statistics
    cfi.printStatistics();

    // In production, this would trigger appropriate security response
    // For now, we panic to make violations obvious during development
    @panic("Control Protection violation detected");
}

// Analyze indirect branch that caused ENDBRANCH violation
fn analyzeIndirectBranch(frame: *exceptions.InterruptFrame) void {
    // Try to decode the instruction at RIP to understand the branch type
    const rip = frame.rip;

    // Look back a few bytes to find the indirect branch instruction
    // Common patterns:
    // - FF 15: CALL [rip+offset]
    // - FF 25: JMP [rip+offset]
    // - FF D0-D7: CALL reg
    // - FF E0-E7: JMP reg

    if (rip >= 6) {
        const inst_ptr = @as([*]const u8, @ptrFromInt(rip - 6));

        // Check for indirect call/jmp patterns
        for (0..6) |offset| {
            const byte = inst_ptr[offset];
            const next_byte = if (offset < 5) inst_ptr[offset + 1] else 0;

            if (byte == 0xFF) {
                switch (next_byte & 0xF8) {
                    0xD0 => serial.println("[CFI] Likely source: CALL register", .{}),
                    0xE0 => serial.println("[CFI] Likely source: JMP register", .{}),
                    else => {},
                }

                if (next_byte == 0x15 or next_byte == 0x25) {
                    serial.println("[CFI] Likely source: {s} [rip+offset]", .{if (next_byte == 0x15) "CALL" else "JMP"});
                }
            }
        }
    }
}

// Get CP exception statistics
pub fn getStatistics() struct {
    total_exceptions: u64,
    near_ret_violations: u64,
    far_ret_violations: u64,
    endbranch_violations: u64,
    shadow_stack_violations: u64,
} {
    return .{
        .total_exceptions = cp_exception_count.load(.monotonic),
        .near_ret_violations = cp_near_ret_violations.load(.monotonic),
        .far_ret_violations = cp_far_ret_violations.load(.monotonic),
        .endbranch_violations = cp_endbranch_violations.load(.monotonic),
        .shadow_stack_violations = cp_shadow_stack_violations.load(.monotonic),
    };
}

// Print CP exception statistics
pub fn printStatistics() void {
    const stats = getStatistics();
    serial.println("[CFI] Control Protection Exception Statistics:", .{});
    serial.println("  Total CP exceptions: {}", .{stats.total_exceptions});
    serial.println("  Near RET violations: {}", .{stats.near_ret_violations});
    serial.println("  Far RET/IRET violations: {}", .{stats.far_ret_violations});
    serial.println("  ENDBRANCH violations: {}", .{stats.endbranch_violations});
    serial.println("  Shadow stack violations: {}", .{stats.shadow_stack_violations});
}
