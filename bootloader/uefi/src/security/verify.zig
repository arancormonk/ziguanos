// Copyright 2025 arancormonk
// SPDX-License-Identifier: MIT

// Kernel verification module
// Handles hash verification and secure boot checks

const std = @import("std");
const uefi = std.os.uefi;
const serial = @import("../drivers/serial.zig");
const boot_protocol = @import("shared");
const sha256 = @import("sha256.zig");
const hmac = @import("hmac.zig");
const policy = @import("policy.zig");
const variable_cache = @import("variable_cache.zig");
const key_management = @import("key_management.zig");
const security_config = @import("security_config");
// Import kernel hash (generated by build system)
const kernel_hash = @import("kernel_hash.zig");
// Import kernel HMAC (generated by build system)
const kernel_hmac = @import("kernel_hmac.zig");

// Expected kernel hash (will be populated by build system)
// In production, this should be:
// 1. Embedded during build time
// 2. Stored in secure UEFI variable
// 3. Loaded from TPM PCR
// 4. Retrieved from secure boot certificate
pub var expected_kernel_hash: ?[boot_protocol.SHA256_SIZE]u8 = kernel_hash.KERNEL_HASH;

// Configuration flags
pub const ENFORCE_HASH_CHECK = true; // Enabled by default for security
pub const ALLOW_UNSIGNED_KERNEL = false; // Disabled by default for security
pub const ENABLE_HMAC_VERIFICATION = true; // Enabled for runtime key-based verification
pub const REQUIRE_AUTHENTICATED_VARIABLES = true; // Enabled for production security

// Verification configuration structure
pub const VerificationConfig = struct {
    require_sha256: bool = ENFORCE_HASH_CHECK,
    require_hmac: bool = ENABLE_HMAC_VERIFICATION,
    allow_dynamic_config: bool = false,
    require_authenticated_variables: bool = REQUIRE_AUTHENTICATED_VARIABLES,

    // Get default configuration based on security policy
    pub fn getDefault() VerificationConfig {
        const security_level = policy.getSecurityLevel();
        // Use the build mode from security_config which properly respects --mode
        const is_development = (security_level == .Development) or (security_config.build_mode == .debug);

        return VerificationConfig{
            .require_sha256 = true,
            .require_hmac = security_level != .Development,
            .allow_dynamic_config = is_development,
            .require_authenticated_variables = !is_development,
        };
    }
};

// HMAC key storage
var hmac_key: ?[32]u8 = null; // 256-bit HMAC key
// Runtime HMAC verification - expected HMAC is stored in UEFI variables
var expected_kernel_hmac: ?[hmac.HMAC_SIZE]u8 = if (kernel_hmac.USE_RUNTIME_HMAC) null else kernel_hmac.KERNEL_HMAC;

pub const VerificationError = error{
    HashMismatch,
    NoExpectedHash,
    VerificationDisabled,
    InvalidVariableAttributes,
    HMACMismatch,
    NoHMACKey,
    InvalidHMACKey,
};

// Constant-time comparison to prevent timing attacks
// This function always processes all bytes regardless of differences
// Enhanced with compiler barriers and timing normalization
fn constantTimeCompare(a: [boot_protocol.SHA256_SIZE]u8, b: [boot_protocol.SHA256_SIZE]u8) bool {
    var result: u8 = 0;

    // Disable runtime safety to prevent compiler optimizations
    @setRuntimeSafety(false);

    // XOR all bytes and accumulate differences
    // This ensures we always process all bytes regardless of content
    for (0..boot_protocol.SHA256_SIZE) |i| {
        result |= a[i] ^ b[i];
    }

    // Re-enable runtime safety
    @setRuntimeSafety(true);

    // Memory barrier to prevent speculation and instruction reordering
    // This ensures the comparison is not optimized away or reordered
    asm volatile (""
        :
        : [result] "r" (result),
        : "memory"
    );

    // Additional timing normalization using RDTSC
    // This helps prevent timing analysis by adding controlled noise
    var timing_low: u32 = undefined;
    var timing_high: u32 = undefined;
    asm volatile (
        \\rdtsc
        : [low] "={eax}" (timing_low),
          [high] "={edx}" (timing_high),
    );

    // Combine the timing values to ensure they're used
    const timing_combined = @as(u64, timing_high) << 32 | timing_low;

    // Second memory barrier after timing read
    asm volatile (""
        :
        : [timing] "r" (timing_combined),
        : "memory"
    );

    // Result is 0 only if all bytes matched
    return result == 0;
}

// Verify kernel hash against expected value
pub fn verifyKernelHash(actual_hash: [boot_protocol.SHA256_SIZE]u8) !bool {
    // If no expected hash is set, check configuration
    if (expected_kernel_hash == null) {
        if (ALLOW_UNSIGNED_KERNEL) {
            // Check policy for unsigned kernel
            policy.checkUnsignedKernel() catch {
                return VerificationError.NoExpectedHash;
            };
            return false;
        } else {
            serial.print("[UEFI] ERROR: No expected kernel hash configured\r\n", .{}) catch {};
            return VerificationError.NoExpectedHash;
        }
    }

    const expected = expected_kernel_hash.?;

    // Use constant-time comparison to prevent timing attacks
    const match = constantTimeCompare(actual_hash, expected);

    if (match) {
        serial.print("[UEFI] Kernel hash verification PASSED\r\n", .{}) catch {};
        return true;
    } else {
        serial.print("[UEFI] ERROR: Kernel hash verification FAILED\r\n", .{}) catch {};
        serial.print("[UEFI] Expected: ", .{}) catch {};
        for (expected) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n[UEFI] Actual:   ", .{}) catch {};
        for (actual_hash) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n", .{}) catch {};

        if (ENFORCE_HASH_CHECK) {
            // Check policy for hash mismatch
            policy.checkHashMismatch() catch {
                return VerificationError.HashMismatch;
            };
            return VerificationError.HashMismatch;
        } else {
            // Policy check even when enforcement is disabled
            policy.checkHashMismatch() catch {
                return VerificationError.HashMismatch;
            };
            return false;
        }
    }
}

// UEFI GUIDs for Secure Boot variables
const SECURE_BOOT_GUID align(8) = uefi.Guid{
    .time_low = 0x8BE4DF61,
    .time_mid = 0x93CA,
    .time_high_and_version = 0x11D2,
    .clock_seq_high_and_reserved = 0xAA,
    .clock_seq_low = 0x0D,
    .node = [_]u8{ 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C },
};

// Ziguanos vendor GUID for our variables
const ZIGUANOS_VENDOR_GUID align(8) = uefi.Guid{
    .time_low = 0x5A494755,
    .time_mid = 0x414E,
    .time_high_and_version = 0x4F53,
    .clock_seq_high_and_reserved = 0x48,
    .clock_seq_low = 0x41,
    .node = [_]u8{ 0x53, 0x48, 0x5A, 0x49, 0x47, 0x55 },
};

// UEFI variable attribute constants (from UEFI Specification)
// These are not defined in Zig's std library, so we define them here
const EFI_VARIABLE_NON_VOLATILE: u32 = 0x00000001;
const EFI_VARIABLE_BOOTSERVICE_ACCESS: u32 = 0x00000002;
const EFI_VARIABLE_RUNTIME_ACCESS: u32 = 0x00000004;
const EFI_VARIABLE_HARDWARE_ERROR_RECORD: u32 = 0x00000008;
const EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS: u32 = 0x00000010;
const EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS: u32 = 0x00000020;
const EFI_VARIABLE_APPEND_WRITE: u32 = 0x00000040;

// Required attributes for secure variable access
const REQUIRED_VARIABLE_ATTRS = EFI_VARIABLE_BOOTSERVICE_ACCESS |
    EFI_VARIABLE_RUNTIME_ACCESS |
    EFI_VARIABLE_NON_VOLATILE;

// Optional authenticated variable attributes (when available)
const AUTHENTICATED_ATTRS = EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS;

// Validate UEFI variable attributes for security
fn validateVariableAttributes(attributes: u32, variable_name: []const u8) bool {
    // Check if variable has minimum required attributes
    const has_required = (attributes & REQUIRED_VARIABLE_ATTRS) == REQUIRED_VARIABLE_ATTRS;

    if (!has_required) {
        serial.print("[UEFI] WARNING: Variable '{s}' missing required attributes: 0x{X}\r\n", .{ variable_name, attributes }) catch {};
        return false;
    }

    // Check if variable is authenticated (best practice for production)
    const is_authenticated = (attributes & AUTHENTICATED_ATTRS) != 0;

    // Determine if we should enforce authenticated variables based on security policy
    const config = VerificationConfig.getDefault();
    const enforce_authenticated = config.require_authenticated_variables;

    if (enforce_authenticated) {
        if (!is_authenticated) {
            const security_level = policy.getSecurityLevel();
            serial.print("[UEFI] ERROR: Variable '{s}' is not authenticated - enforcing in {s} mode\r\n", .{ variable_name, @tagName(security_level) }) catch {};
            // Check policy for unauthenticated variables - this will halt boot in production/strict mode
            policy.checkVariableAuthentication(variable_name, is_authenticated) catch {
                return false;
            };
            return false; // Reject unauthenticated variables in production/strict mode
        }
    } else {
        // In development mode or when not required, just warn about unauthenticated variables
        if (!is_authenticated) {
            serial.print("[UEFI] WARNING: Variable '{s}' is not authenticated - security risk!\r\n", .{variable_name}) catch {};
        }
        // Check policy for logging/auditing purposes
        policy.checkVariableAuthentication(variable_name, is_authenticated) catch {
            // In development mode, we don't fail on policy violations for unauthenticated variables
            const security_level = policy.getSecurityLevel();
            if (security_level == .Development) {
                return true; // Continue despite policy violation
            }
            return false;
        };
    }

    // Log successful authentication check in audit mode
    if (is_authenticated) {
        policy.auditCheckPassed("Variable authentication");
    }

    return true;
}

// Load expected hash from UEFI variable cache
pub fn loadExpectedHashFromUEFI(runtime_services: *uefi.tables.RuntimeServices) !void {
    // Initialize cache if not already done
    if (!variable_cache.isInitialized()) {
        try variable_cache.init(runtime_services);
    }

    // Get hash from cache
    if (variable_cache.getKernelHash()) |cached| {
        // Validate variable attributes for security
        if (!validateVariableAttributes(cached.attrs, "ZiguanosHash")) {
            serial.print("[UEFI] ERROR: Kernel hash variable has invalid attributes\r\n", .{}) catch {};
            if (ENFORCE_HASH_CHECK) {
                return error.InvalidVariableAttributes;
            }
        }

        expected_kernel_hash = cached.hash;
        serial.print("[UEFI] Loaded kernel hash from cache (attributes: 0x{X})\r\n", .{cached.attrs}) catch {};

        // Log hash for audit purposes
        serial.print("[UEFI] Expected hash: ", .{}) catch {};
        for (cached.hash) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n", .{}) catch {};
    } else {
        serial.print("[UEFI] No kernel hash found in cache\r\n", .{}) catch {};
    }
}

// Calculate hash of loaded kernel in memory (post-relocation verification)
pub fn hashLoadedKernel(base_addr: u64, size: usize) [boot_protocol.SHA256_SIZE]u8 {
    const kernel_mem = @as([*]const u8, @ptrFromInt(base_addr))[0..size];
    return sha256.sha256(kernel_mem);
}

// Post-relocation integrity verification
// This function verifies kernel integrity after KASLR relocations
pub fn verifyPostRelocationIntegrity(base_addr: u64, size: usize, expected_hash: ?[boot_protocol.SHA256_SIZE]u8) !bool {
    // Calculate current hash of kernel in memory
    const current_hash = hashLoadedKernel(base_addr, size);

    // If we have an expected post-relocation hash, compare it
    if (expected_hash) |expected| {
        const match = constantTimeCompare(current_hash, expected);

        if (!match) {
            serial.print("[UEFI] ERROR: Post-relocation integrity check FAILED\r\n", .{}) catch {};
            serial.print("[UEFI] Expected: ", .{}) catch {};
            for (expected) |byte| {
                serial.print("{X:0>2}", .{byte}) catch {};
            }
            serial.print("\r\n[UEFI] Actual:   ", .{}) catch {};
            for (current_hash) |byte| {
                serial.print("{X:0>2}", .{byte}) catch {};
            }
            serial.print("\r\n", .{}) catch {};

            if (ENFORCE_HASH_CHECK) {
                return VerificationError.HashMismatch;
            }
            return false;
        }

        serial.print("[UEFI] Post-relocation integrity check PASSED\r\n", .{}) catch {};
        return true;
    }

    // No expected hash available - log the current hash for future use
    serial.print("[UEFI] Post-relocation hash calculated (no verification possible)\r\n", .{}) catch {};
    return false;
}

// Load expected post-relocation hash from UEFI variable cache
pub fn loadExpectedPostRelocationHashFromUEFI(runtime_services: *uefi.tables.RuntimeServices) ?[boot_protocol.SHA256_SIZE]u8 {
    // Initialize cache if not already done
    if (!variable_cache.isInitialized()) {
        variable_cache.init(runtime_services) catch {
            serial.print("[UEFI] Failed to initialize variable cache\r\n", .{}) catch {};
            return null;
        };
    }

    // Get hash from cache
    if (variable_cache.getPostRelocationHash()) |cached| {
        // Validate variable attributes for security
        if (!validateVariableAttributes(cached.attrs, "ZiguanosPostHash")) {
            serial.print("[UEFI] ERROR: Post-relocation hash variable has invalid attributes\r\n", .{}) catch {};
            if (ENFORCE_HASH_CHECK) {
                return null; // Treat as missing hash if attributes are invalid
            }
        }

        serial.print("[UEFI] Loaded post-relocation hash from cache (attributes: 0x{X})\r\n", .{cached.attrs}) catch {};
        return cached.hash;
    }

    return null;
}

// Verify TPM measurements (for production use)
pub fn verifyTPMMeasurements() !void {
    // TODO: Implement TPM communication
    // 1. Extend PCR with kernel hash
    // 2. Verify PCR values match expected
    // 3. Quote PCR values for remote attestation
}

// Check UEFI Secure Boot status
pub fn checkSecureBootStatus(system_table: *uefi.tables.SystemTable) bool {
    var secure_boot: u8 = 0;
    var data_size: usize = @sizeOf(u8);
    var attributes: u32 = undefined;

    const status = system_table.runtime_services.getVariable(
        &[_:0]u16{ 'S', 'e', 'c', 'u', 'r', 'e', 'B', 'o', 'o', 't', 0 },
        &SECURE_BOOT_GUID,
        &attributes,
        &data_size,
        &secure_boot,
    );

    if (status == .success and secure_boot == 1) {
        serial.print("[UEFI] UEFI Firmware Secure Boot: ENABLED\r\n", .{}) catch {};
        return true;
    } else {
        serial.print("[UEFI] UEFI Firmware Secure Boot: DISABLED (kernel verification still active)\r\n", .{}) catch {};
        return false;
    }
}

// Store kernel hash in authenticated UEFI variable
pub fn storeKernelHash(runtime_services: *uefi.tables.RuntimeServices, hash: [boot_protocol.SHA256_SIZE]u8) !void {
    // Use authenticated variable attributes for production security
    // Note: TIME_BASED_AUTHENTICATED_WRITE_ACCESS requires proper signing
    const config = VerificationConfig.getDefault();
    const use_authenticated = config.require_authenticated_variables;

    const attrs = if (use_authenticated)
        REQUIRED_VARIABLE_ATTRS | AUTHENTICATED_ATTRS
    else
        REQUIRED_VARIABLE_ATTRS;

    const status = runtime_services.setVariable(
        &[_:0]u16{ 'Z', 'i', 'g', 'u', 'a', 'n', 'o', 's', 'H', 'a', 's', 'h', 0 },
        &ZIGUANOS_VENDOR_GUID,
        attrs,
        boot_protocol.SHA256_SIZE,
        &hash,
    );

    if (status != .success) {
        serial.print("[UEFI] Failed to store kernel hash in UEFI variable (status: {})\r\n", .{status}) catch {};
        return error.VariableStoreFailed;
    }

    serial.print("[UEFI] Kernel hash stored in UEFI variable (attributes: 0x{X})\r\n", .{attrs}) catch {};
    if (use_authenticated) {
        serial.print("[UEFI] Variable stored with authenticated write access\r\n", .{}) catch {};
    } else {
        serial.print("[UEFI] WARNING: Variable stored without authentication - update PKI for production\r\n", .{}) catch {};
    }

    // Log stored hash for audit purposes
    serial.print("[UEFI] Stored hash: ", .{}) catch {};
    for (hash) |byte| {
        serial.print("{X:0>2}", .{byte}) catch {};
    }
    serial.print("\r\n", .{}) catch {};
}

// Load HMAC key from UEFI variable cache with authentication checks
pub fn loadHMACKeyFromUEFI(runtime_services: *uefi.tables.RuntimeServices) !void {
    // Initialize cache if not already done
    if (!variable_cache.isInitialized()) {
        try variable_cache.init(runtime_services);
    }

    // Get key from cache
    if (variable_cache.getHMACKey()) |cached| {
        // SECURITY: HMAC keys must be stored in authenticated variables
        if (!validateVariableAttributes(cached.attrs, "ZiguanosHMACKey")) {
            serial.print("[UEFI] ERROR: HMAC key variable has invalid attributes\r\n", .{}) catch {};
            if (ENABLE_HMAC_VERIFICATION and ENFORCE_HASH_CHECK) {
                return error.InvalidVariableAttributes;
            }
        }

        // Check if variable is authenticated - critical for HMAC keys
        const is_authenticated = (cached.attrs & AUTHENTICATED_ATTRS) != 0;
        if (!is_authenticated and ENABLE_HMAC_VERIFICATION) {
            serial.print("[UEFI] WARNING: HMAC key stored in non-authenticated variable - security risk!\r\n", .{}) catch {};
            // In production, this should be an error
            policy.checkUnsignedKernel() catch {
                return error.InvalidHMACKey;
            };
        }

        hmac_key = cached.key;
        serial.print("[UEFI] Loaded HMAC key from cache (attributes: 0x{X})\r\n", .{cached.attrs}) catch {};

        // Don't log the actual key for security
        serial.print("[UEFI] HMAC key loaded successfully (256-bit)\r\n", .{}) catch {};
    } else {
        if (ENABLE_HMAC_VERIFICATION) {
            serial.print("[UEFI] No HMAC key found in cache\r\n", .{}) catch {};
        }
    }
}

// Load expected HMAC from UEFI variable cache
pub fn loadExpectedHMACFromUEFI(runtime_services: *uefi.tables.RuntimeServices) !void {
    // Initialize cache if not already done
    if (!variable_cache.isInitialized()) {
        try variable_cache.init(runtime_services);
    }

    // Get HMAC from cache
    if (variable_cache.getKernelHMAC()) |cached| {
        // Validate variable attributes for security
        if (!validateVariableAttributes(cached.attrs, "ZiguanosHMAC")) {
            serial.print("[UEFI] ERROR: Kernel HMAC variable has invalid attributes\r\n", .{}) catch {};
            if (ENABLE_HMAC_VERIFICATION and ENFORCE_HASH_CHECK) {
                return error.InvalidVariableAttributes;
            }
        }

        expected_kernel_hmac = cached.hmac;
        serial.print("[UEFI] Loaded kernel HMAC from cache (attributes: 0x{X})\r\n", .{cached.attrs}) catch {};

        // Log HMAC for audit purposes (safe to log HMAC value)
        serial.print("[UEFI] Expected HMAC: ", .{}) catch {};
        for (cached.hmac) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n", .{}) catch {};
    } else {
        if (ENABLE_HMAC_VERIFICATION) {
            serial.print("[UEFI] No kernel HMAC found in cache\r\n", .{}) catch {};
        }
    }
}

// Verify kernel HMAC for authentication
pub fn verifyKernelHMAC(handle: uefi.Handle, boot_services: *uefi.tables.BootServices, kernel_data: []const u8) !bool {
    _ = handle; // Will be used in future for file operations
    _ = boot_services; // Runtime services accessed via system table
    if (!ENABLE_HMAC_VERIFICATION) {
        return true; // HMAC verification disabled
    }

    // Try to load HMAC key if not already loaded
    if (hmac_key == null) {
        // Get the system table to access runtime services
        const uefi_globals = @import("../utils/uefi_globals.zig");
        const runtime_services = uefi_globals.system_table.runtime_services;

        // Use secure key management to get or create kernel HMAC key
        const key_record = key_management.getOrCreateKey(
            runtime_services,
            .KernelHMAC,
        ) catch |err| {
            serial.print("[UEFI] ERROR: Cannot load or create HMAC key: {}\r\n", .{err}) catch {};
            if (ENFORCE_HASH_CHECK) {
                return VerificationError.NoHMACKey;
            }
            return false;
        };

        hmac_key = key_record.key_material;
        serial.print("[UEFI] Loaded HMAC key from secure storage (type: KernelHMAC)\r\n", .{}) catch {};
    }

    // For runtime HMAC, load expected value from UEFI variable
    if (expected_kernel_hmac == null and kernel_hmac.USE_RUNTIME_HMAC) {
        // Try to load expected HMAC from UEFI variable
        const uefi_globals = @import("../utils/uefi_globals.zig");
        const runtime_services = uefi_globals.system_table.runtime_services;

        if (loadKernelHMACFromUEFI(runtime_services)) |loaded_hmac| {
            expected_kernel_hmac = loaded_hmac;
        } else |err| {
            serial.print("[UEFI] Failed to load expected kernel HMAC: {}\r\n", .{err}) catch {};

            // On first boot, calculate and store the HMAC
            serial.print("[UEFI] First boot detected - calculating kernel HMAC\r\n", .{}) catch {};
            const computed_hmac = hmac.hmacSha256(&hmac_key.?, kernel_data) catch |compute_err| {
                serial.print("[UEFI] ERROR: Failed to compute initial HMAC: {}\r\n", .{compute_err}) catch {};
                return VerificationError.HMACMismatch;
            };

            // Store for future boots
            storeKernelHMAC(runtime_services, computed_hmac) catch |store_err| {
                serial.print("[UEFI] ERROR: Failed to store initial HMAC: {}\r\n", .{store_err}) catch {};
                if (ENFORCE_HASH_CHECK) {
                    return VerificationError.NoExpectedHash;
                }
            };

            // Use the just-calculated HMAC for this boot
            expected_kernel_hmac = computed_hmac;
            serial.print("[UEFI] Kernel HMAC initialized for future verification\r\n", .{}) catch {};
        }
    }

    if (expected_kernel_hmac == null) {
        serial.print("[UEFI] WARNING: No expected HMAC available for verification\r\n", .{}) catch {};
        if (ENFORCE_HASH_CHECK) {
            return VerificationError.NoExpectedHash;
        }
        return false;
    }

    const key = hmac_key.?;
    const expected = expected_kernel_hmac.?;

    // Calculate HMAC of kernel data
    const computed_hmac = hmac.hmacSha256(&key, kernel_data) catch |err| {
        serial.print("[UEFI] ERROR: Failed to compute HMAC: {}\r\n", .{err}) catch {};
        return VerificationError.HMACMismatch;
    };

    // Use constant-time comparison
    const match = hmac.verifyHMAC(computed_hmac, expected);

    if (match) {
        serial.print("[UEFI] Kernel HMAC verification PASSED\r\n", .{}) catch {};
        return true;
    } else {
        serial.print("[UEFI] ERROR: Kernel HMAC verification FAILED\r\n", .{}) catch {};
        serial.print("[UEFI] Expected: ", .{}) catch {};
        for (expected) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n[UEFI] Computed: ", .{}) catch {};
        for (computed_hmac) |byte| {
            serial.print("{X:0>2}", .{byte}) catch {};
        }
        serial.print("\r\n", .{}) catch {};

        if (ENFORCE_HASH_CHECK) {
            // Check policy for HMAC mismatch
            policy.checkHashMismatch() catch {
                return VerificationError.HMACMismatch;
            };
            return VerificationError.HMACMismatch;
        }
        return false;
    }
}

// Store HMAC key in authenticated UEFI variable
pub fn storeHMACKey(runtime_services: *uefi.tables.RuntimeServices, key: [32]u8) !void {
    // SECURITY: HMAC keys MUST use authenticated variables in production
    const config = VerificationConfig.getDefault();
    const use_authenticated = config.require_authenticated_variables;

    // HMAC keys are especially critical and should always be authenticated in production
    const attrs = if (use_authenticated)
        REQUIRED_VARIABLE_ATTRS | AUTHENTICATED_ATTRS
    else
        REQUIRED_VARIABLE_ATTRS;

    const status = runtime_services.setVariable(
        &[_:0]u16{ 'Z', 'i', 'g', 'u', 'a', 'n', 'o', 's', 'H', 'M', 'A', 'C', 'K', 'e', 'y', 0 },
        &ZIGUANOS_VENDOR_GUID,
        attrs,
        32,
        @constCast(@ptrCast(&key)),
    );

    if (status != .success) {
        serial.print("[UEFI] Failed to store HMAC key in UEFI variable (status: {})\r\n", .{status}) catch {};
        return error.VariableStoreFailed;
    }

    serial.print("[UEFI] HMAC key stored in UEFI variable (attributes: 0x{X})\r\n", .{attrs}) catch {};
    if (use_authenticated) {
        serial.print("[UEFI] HMAC key stored with authenticated write access - secure\r\n", .{}) catch {};
    } else {
        serial.print("[UEFI] CRITICAL WARNING: HMAC key stored without authentication - HIGH SECURITY RISK!\r\n", .{}) catch {};
        serial.print("[UEFI] Configure PKI infrastructure for production deployments\r\n", .{}) catch {};
    }
}

// Load kernel HMAC from UEFI variable
pub fn loadKernelHMACFromUEFI(runtime_services: *uefi.tables.RuntimeServices) ![hmac.HMAC_SIZE]u8 {
    var hmac_value: [hmac.HMAC_SIZE]u8 = undefined;
    var data_size: usize = hmac.HMAC_SIZE;
    var attributes: u32 = undefined;

    const status = runtime_services.getVariable(
        &[_:0]u16{ 'Z', 'i', 'g', 'u', 'a', 'n', 'o', 's', 'H', 'M', 'A', 'C', 0 },
        &ZIGUANOS_VENDOR_GUID,
        &attributes,
        &data_size,
        @ptrCast(&hmac_value),
    );

    if (status != .success) {
        serial.print("[UEFI] No kernel HMAC found in UEFI variable (status: {})\r\n", .{status}) catch {};
        return error.HMACNotFound;
    }

    if (data_size != hmac.HMAC_SIZE) {
        serial.print("[UEFI] Invalid HMAC size in UEFI variable: {} (expected {})\r\n", .{ data_size, hmac.HMAC_SIZE }) catch {};
        return error.InvalidHMACSize;
    }

    // Validate variable attributes for security
    if (!validateVariableAttributes(attributes, "ZiguanosHMAC")) {
        serial.print("[UEFI] WARNING: Kernel HMAC variable has insecure attributes\r\n", .{}) catch {};
        if (ENFORCE_HASH_CHECK and policy.getSecurityLevel() == .Strict) {
            return VerificationError.InvalidVariableAttributes;
        }
    }

    serial.print("[UEFI] Loaded kernel HMAC from UEFI variable\r\n", .{}) catch {};
    return hmac_value;
}

// Store kernel HMAC in UEFI variable
pub fn storeKernelHMAC(runtime_services: *uefi.tables.RuntimeServices, hmac_value: [hmac.HMAC_SIZE]u8) !void {
    const config = VerificationConfig.getDefault();
    const use_authenticated = config.require_authenticated_variables;

    const attrs = if (use_authenticated)
        REQUIRED_VARIABLE_ATTRS | AUTHENTICATED_ATTRS
    else
        REQUIRED_VARIABLE_ATTRS;

    const status = runtime_services.setVariable(
        &[_:0]u16{ 'Z', 'i', 'g', 'u', 'a', 'n', 'o', 's', 'H', 'M', 'A', 'C', 0 },
        &ZIGUANOS_VENDOR_GUID,
        attrs,
        hmac.HMAC_SIZE,
        @constCast(@ptrCast(&hmac_value)),
    );

    if (status != .success) {
        serial.print("[UEFI] Failed to store kernel HMAC in UEFI variable (status: {})\r\n", .{status}) catch {};

        // In development/debug builds, try fallback to non-authenticated variables
        const fallback_config = VerificationConfig.getDefault();
        if (fallback_config.allow_dynamic_config and use_authenticated) {
            serial.print("[UEFI] Attempting fallback to non-authenticated variable storage\r\n", .{}) catch {};
            const fallback_attrs = REQUIRED_VARIABLE_ATTRS;
            const fallback_status = runtime_services.setVariable(
                &[_:0]u16{ 'Z', 'i', 'g', 'u', 'a', 'n', 'o', 's', 'H', 'M', 'A', 'C', 0 },
                &ZIGUANOS_VENDOR_GUID,
                fallback_attrs,
                hmac.HMAC_SIZE,
                @constCast(@ptrCast(&hmac_value)),
            );

            if (fallback_status == .success) {
                serial.print("[UEFI] Kernel HMAC stored using fallback non-authenticated variable (development mode)\r\n", .{}) catch {};
            } else {
                serial.print("[UEFI] Fallback storage also failed (status: {})\r\n", .{fallback_status}) catch {};
                return error.VariableStoreFailed;
            }
        } else {
            return error.VariableStoreFailed;
        }
    }

    serial.print("[UEFI] Kernel HMAC stored in UEFI variable (attributes: 0x{X})\r\n", .{attrs}) catch {};
    if (use_authenticated) {
        serial.print("[UEFI] Kernel HMAC stored with authenticated write access\r\n", .{}) catch {};
    } else {
        serial.print("[UEFI] WARNING: Kernel HMAC stored without authentication - update PKI for production\r\n", .{}) catch {};
    }

    // Log stored HMAC for audit purposes
    serial.print("[UEFI] Stored HMAC: ", .{}) catch {};
    for (hmac_value) |byte| {
        serial.print("{X:0>2}", .{byte}) catch {};
    }
    serial.print("\r\n", .{}) catch {};
}

// Enhanced RDRAND implementation with entropy conditioning
fn rdrand64() ?u64 {
    var result: u64 = undefined;
    var cf: u8 = undefined;
    var retry_count: u32 = 0;

    // Retry up to 10 times as per Intel recommendation
    while (retry_count < 10) : (retry_count += 1) {
        asm volatile (
            \\rdrand %[result]
            \\setc %[cf]
            : [result] "=r" (result),
              [cf] "=r" (cf),
            :
            : "cc"
        );

        if (cf == 1) {
            // Apply whitening/conditioning as per NIST SP 800-90B
            const tsc_value = getTSCValue();
            const perf_counter = getPerformanceCounter();
            const mixed_entropy = result ^ tsc_value ^ perf_counter;

            // Additional entropy from stack pointer for ASLR
            const stack_entropy = asm volatile ("mov %%rsp, %[result]"
                : [result] "=r" (-> u64),
            );

            return mixed_entropy ^ stack_entropy;
        }
    }

    serial.print("[UEFI] WARNING: RDRAND failed after 10 attempts\r\n", .{}) catch {};
    return null;
}

// Get TSC value for entropy mixing
fn getTSCValue() u64 {
    var low: u32 = undefined;
    var high: u32 = undefined;

    asm volatile (
        \\rdtsc
        : [low] "={eax}" (low),
          [high] "={edx}" (high),
        :
        : "cc"
    );

    return (@as(u64, high) << 32) | @as(u64, low);
}

// Get performance counter for additional entropy
fn getPerformanceCounter() u64 {
    var result: u64 = undefined;

    // Use performance counter 0 if available
    asm volatile (
        \\rdpmc
        : [result] "={rax}" (result),
        : [counter] "{rcx}" (0),
        : "cc", "rdx"
    );

    return result;
}

// Generate secure random HMAC key using enhanced hardware RNG
pub fn generateHMACKey() ![32]u8 {
    var key: [32]u8 = undefined;
    var entropy_quality_score: u32 = 0;

    // Generate 256 bits of random data with quality assessment
    for (0..4) |i| {
        const rand64 = rdrand64() orelse {
            serial.print("[UEFI] ERROR: Failed to generate random data for HMAC key (attempt {})\r\n", .{i + 1}) catch {};
            return error.RNGFailure;
        };

        // Assess entropy quality (basic check for obvious patterns)
        entropy_quality_score += assessEntropyQuality(rand64);

        // Store 64 bits at a time with proper byte ordering
        const bytes = @as([8]u8, @bitCast(rand64));
        for (bytes, 0..) |byte, j| {
            key[i * 8 + j] = byte;
        }
    }

    // Validate entropy quality
    if (entropy_quality_score < 12) { // Minimum acceptable quality threshold
        serial.print("[UEFI] WARNING: Low entropy quality detected (score: {})\r\n", .{entropy_quality_score}) catch {};

        // Apply additional entropy mixing for low-quality RNG
        mixAdditionalEntropy(&key);
    }

    // Final validation - ensure key is not all zeros or all ones
    if (isWeakKey(key)) {
        serial.print("[UEFI] ERROR: Generated weak HMAC key, rejecting\r\n", .{}) catch {};
        return error.WeakKey;
    }

    serial.print("[UEFI] Generated 256-bit HMAC key using enhanced hardware RNG (quality: {})\r\n", .{entropy_quality_score}) catch {};
    return key;
}

// Assess basic entropy quality of a 64-bit value
fn assessEntropyQuality(value: u64) u32 {
    var score: u32 = 0;

    // Check for bit distribution
    const popcount = @popCount(value);
    if (popcount >= 24 and popcount <= 40) { // Good bit balance
        score += 2;
    } else if (popcount >= 16 and popcount <= 48) { // Acceptable bit balance
        score += 1;
    }

    // Check for obvious patterns (all same bits, alternating patterns)
    if (value != 0 and value != 0xFFFFFFFFFFFFFFFF) {
        score += 1;
    }

    // Check for alternating bit patterns
    if (value != 0x5555555555555555 and value != 0xAAAAAAAAAAAAAAAA) {
        score += 1;
    }

    return score;
}

// Mix additional entropy for low-quality RNG output
fn mixAdditionalEntropy(key: *[32]u8) void {
    const additional_entropy = getTSCValue() ^ getPerformanceCounter();
    const entropy_bytes = @as([8]u8, @bitCast(additional_entropy));

    // XOR additional entropy throughout the key
    for (key, 0..) |*byte, i| {
        byte.* ^= entropy_bytes[i % 8];
    }
}

// Check if generated key is weak (common patterns)
fn isWeakKey(key: [32]u8) bool {
    // Check for all zeros
    for (key) |byte| {
        if (byte != 0) break;
    } else return true;

    // Check for all ones
    for (key) |byte| {
        if (byte != 0xFF) break;
    } else return true;

    // Check for repeating single byte pattern
    const first_byte = key[0];
    for (key[1..]) |byte| {
        if (byte != first_byte) break;
    } else return true;

    return false;
}

// Verifies the integrity of a configuration file buffer against its corresponding .hmac file.
// This function embodies the "fail-secure" principle: any doubt leads to rejection.
//
// Parameters:
//   - handle: The image handle for accessing the loaded image protocol
//   - boot_services: Boot services for protocol access
//   - config_path: The path to the original configuration file (e.g., "ziguanos.conf")
//   - config_data: The raw byte slice of the configuration file that was read into memory
//
// Returns:
//   - `true` if the HMAC is valid
//   - `false` if verification fails for any reason (missing key, missing HMAC file, mismatch)
pub fn verifyConfigurationIntegrity(
    handle: uefi.Handle,
    boot_services: *uefi.tables.BootServices,
    config_path: []const u8,
    config_data: []const u8,
) bool {
    // Try to load HMAC key if not already loaded
    if (hmac_key == null) {
        // Get the system table to access runtime services
        const uefi_globals = @import("../utils/uefi_globals.zig");
        const runtime_services = uefi_globals.system_table.runtime_services;

        // Use secure key management to get or create config HMAC key
        const key_record = key_management.getOrCreateKey(
            runtime_services,
            .ConfigHMAC,
        ) catch |err| {
            serial.print("[UEFI] ERROR: Cannot load or create config HMAC key: {}. Rejecting config.\r\n", .{err}) catch {};
            return false;
        };

        hmac_key = key_record.key_material;
        serial.print("[UEFI] Loaded HMAC key from secure storage (type: ConfigHMAC)\r\n", .{}) catch {};
    }

    // Construct HMAC path from config path (e.g., "ziguanos.conf" -> "ziguanos.conf.hmac")
    var hmac_path_buf: [256]u8 = undefined;
    const hmac_path = std.fmt.bufPrint(&hmac_path_buf, "{s}.hmac", .{config_path}) catch |err| {
        serial.print("[UEFI] ERROR: Failed to construct HMAC path: {}\r\n", .{err}) catch {};
        return false;
    };

    // Read the corresponding HMAC file from the file system
    const hmac_data = readFileFromEFI(handle, boot_services, hmac_path) catch |err| {
        serial.print("[UEFI] WARNING: Config file '{s}' exists but its HMAC file is missing or unreadable: {}\r\n", .{ config_path, err }) catch {};
        return false;
    };
    defer uefi.pool_allocator.free(hmac_data);

    if (hmac_data.len != hmac.HMAC_SIZE * 2) { // Expect hex-encoded (64 chars for 32 bytes)
        serial.print("[UEFI] WARNING: Invalid HMAC file size for '{s}'. Expected {d} hex chars, got {d}. Rejecting config.\r\n", .{ config_path, hmac.HMAC_SIZE * 2, hmac_data.len }) catch {};
        return false;
    }

    // Parse hex-encoded HMAC
    var expected_hmac: [hmac.HMAC_SIZE]u8 = undefined;
    for (0..hmac.HMAC_SIZE) |i| {
        const hex_chars = hmac_data[i * 2 .. i * 2 + 2];
        expected_hmac[i] = std.fmt.parseInt(u8, hex_chars, 16) catch |parse_err| {
            serial.print("[UEFI] ERROR: Invalid hex in HMAC file: {}\r\n", .{parse_err}) catch {};
            return false;
        };
    }

    // Calculate HMAC of the config data and compare with the expected HMAC from the file
    const computed_hmac = hmac.hmacSha256(&hmac_key.?, config_data) catch |err| {
        serial.print("[UEFI] ERROR: Failed to compute HMAC: {}\r\n", .{err}) catch {};
        return false;
    };

    return hmac.verifyHMAC(computed_hmac, expected_hmac);
}

// Helper function to read a file from the EFI System Partition with TOCTOU protection
// This implementation eliminates the time window between size check and content read
fn readFileFromEFI(handle: uefi.Handle, boot_services: *uefi.tables.BootServices, file_path: []const u8) ![]u8 {
    // Get LoadedImage protocol
    const loaded_image_guid align(8) = uefi.protocol.LoadedImage.guid;
    var loaded_image: *uefi.protocol.LoadedImage = undefined;

    var status = boot_services.openProtocol(
        handle,
        &loaded_image_guid,
        @ptrCast(&loaded_image),
        handle,
        null,
        .{ .by_handle_protocol = true },
    );

    if (status != .success) {
        return error.ProtocolNotFound;
    }

    // Get SimpleFileSystem protocol
    const simple_file_system_guid align(8) = uefi.protocol.SimpleFileSystem.guid;
    var file_system: *uefi.protocol.SimpleFileSystem = undefined;

    status = boot_services.openProtocol(
        loaded_image.device_handle.?,
        &simple_file_system_guid,
        @ptrCast(&file_system),
        handle,
        null,
        .{ .by_handle_protocol = true },
    );

    if (status != .success) {
        return error.FileSystemNotFound;
    }

    // Open root directory
    var root_dir: *const uefi.protocol.File = undefined;
    status = file_system.openVolume(&root_dir);
    if (status != .success) {
        return error.VolumeOpenFailed;
    }

    // Convert file path to UTF-16
    var utf16_path: [256:0]u16 = undefined;
    var i: usize = 0;
    while (i < file_path.len and i < 255) : (i += 1) {
        utf16_path[i] = file_path[i];
    }
    utf16_path[i] = 0; // Null terminate

    // Open file
    var file: *const uefi.protocol.File = undefined;
    status = root_dir.open(
        &file,
        &utf16_path,
        uefi.protocol.File.efi_file_mode_read,
        0,
    );

    if (status != .success) {
        return error.FileNotFound;
    }

    // Maximum file size for config files and similar (32MB)
    // This is generous but prevents excessive allocation
    const MAX_FILE_SIZE: usize = 32 * 1024 * 1024;

    // Allocate generous initial buffer to eliminate TOCTOU window
    // We allocate the maximum size upfront, then trim after reading
    var initial_buffer = try uefi.pool_allocator.alloc(u8, MAX_FILE_SIZE);
    defer uefi.pool_allocator.free(initial_buffer);

    // Read file content in a single atomic operation
    var bytes_read: usize = MAX_FILE_SIZE;
    status = file.read(&bytes_read, initial_buffer.ptr);

    if (status != .success) {
        return error.FileReadFailed;
    }

    // Now we know the actual file size from what was read
    // Allocate exact-sized buffer and copy the data
    const final_buffer = try uefi.pool_allocator.alloc(u8, bytes_read);
    @memcpy(final_buffer[0..bytes_read], initial_buffer[0..bytes_read]);

    // For config files, verify the read was complete by attempting another read
    // If we get any additional bytes, the file was modified during read
    var verification_byte: [1]u8 = undefined;
    var extra_bytes: usize = 1;
    status = file.read(&extra_bytes, &verification_byte);

    if (status == .success and extra_bytes > 0) {
        // File grew during read - this is a potential attack
        uefi.pool_allocator.free(final_buffer);
        serial.print("[UEFI] ERROR: File '{s}' was modified during read (TOCTOU detected)\r\n", .{file_path}) catch {};
        return error.FileTamperingDetected;
    }

    return final_buffer;
}
